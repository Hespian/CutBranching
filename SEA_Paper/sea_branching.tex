\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"

\usepackage{todonotes}
\usepackage{numprint}
\npstyleenglish
\usepackage{placeins}

\usepackage[ruled,vlined,linesnumbered,norelsize]{algorithm2e}
\DontPrintSemicolon
\def\NlSty#1{\textnormal{\fontsize{8}{10}\selectfont{}#1}}
\SetKwSty{texttt}
\SetCommentSty{emph}
\def\algorithmautorefname{Algorithm}

\listfiles

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Faster Maximum Independent Sets using Targeted Branching} %TODO Please add

\titlerunning{Faster MIS using Targeted Branching} %TODO optional, please use if title is longer than one line

% \author{John Q. Public}{Dummy University Computing Laboratory, [optional: Address], Country \and My second affiliation, Country \and \url{http://www.myhomepage.edu} }{johnqpublic@dummyuni.org}{https://orcid.org/0000-0002-1825-0097}{(Optional) author-specific funding acknowledgements}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional

\author{Demian Hespe}{Karlsruhe Institute of Technology, Institute for
  Theoretical Informatics, Germany}{hespe@kit.edu}{}{}

\author{Sebastian Lamm}{Karlsruhe Institute of Technology, Institute for
  Theoretical Informatics, Germany}{lamm@kit.edu}{}{\todo{Add funding}}

\author{Christian Schorr}{Karlsruhe Institute of Technology, Institute for
  Theoretical Informatics, Germany}{christian.schorr@student.kit.edu}{}{}

\authorrunning{D. Hespe and S. Lamm and C. Schorr} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Demian Hespe and Sebastian Lamm and Christian Schorr} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/
\begin{CCSXML}
  <ccs2012>
  <concept>
  <concept_id>10002950.10003624.10003633.10010917</concept_id>
  <concept_desc>Mathematics of computing~Graph algorithms</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10003809.10011254.10011256</concept_id>
  <concept_desc>Theory of computation~Branch-and-bound</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10002950.10003624.10003625.10003630</concept_id>
  <concept_desc>Mathematics of computing~Combinatorial optimization</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Mathematics of computing~Graph algorithms}
\ccsdesc[500]{Theory of computation~Branch-and-bound}
\ccsdesc[500]{Mathematics of computing~Combinatorial optimization}
% \ccsdesc[100]{\textcolor{red}{Replace ccsdesc macro with valid oll
% ne}} %TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

\keywords{Graphs, Combinatorial Optimization, Independent Set, Vertex Cover, Clique, Branch
  and Reduce, Kernelization}%TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{}%optional

%\nolinenumbers %uncomment to disable line numbering

% \hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Custom
\usepackage{xspace}
\newcommand{\ie}{i.\,e.,\xspace}
\newcommand{\eg}{e.\,g.,\xspace}
\newcommand{\etal}{et~al.\xspace}
\newcommand{\Wlog}{w.\,l.\,o.\,g.\ }
\newcommand{\wrt}{w.\,r.\,t.\xspace}

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
  \todo{Write Abstract}
\end{abstract}

\newpage

\section{Introduction}

An \emph{independent set} of a graph $G = (V,E)$ is a set of vertices $I \subseteq V$ of $G$ such that no two vertices in this set are adjacent.
The problem of finding such an independent set of maximum cardinality, the \emph{maximum independent set problem}, is a fundamental NP-hard problem~\cite{Garey1974}.
Its applications cover a wide variety of fields including computer graphics \cite{CG}, network analysis \cite{NW}, route planning \cite{RP} and computational biology \cite{BIO1, BIO2}.
In computer graphics for instance, large independent sets can be used to optimize the traversal of mesh edges in a triangle mesh.
Further applications stem from its complementary problems minimum vertex cover and maximum clique.

One of the best known techniques for finding maximum independent sets, both in theory~\cite{XiaoNagamochi, ChenXiaKanj} and practice \cite{AkibaIwata}, are \emph{kernelization algorithms}.
These algorithms apply a set of reduction rules to decrease the complexity of an instance while maintaining the ability to compute an optimal solution afterwards.
A recently successful type of kernelization algorithms are so-called \emph{branch-and-reduce algorithms}~\cite{AkibaIwata,WGYC}, which exhaustively apply a set of reduction rules to compute a \emph{kernel}.
If no further rule can be applied, the algorithm branches into (at least) two subproblems of lower complexity, which are then solved recursively.
To make them more efficient in practice, these algorithms also make use of problem specific upper and lower bounds to quickly prune the search space.

Due to the practical impact of kernelization, most of the research aimed at improving the performance of branch-and-reduce algorithms so far has been focused on either proposing more practically efficient special cases of already existing rules~\cite{ChangKern,dahlum2016accelerating}, or maintaining dependencies between reduction rules to reduce unnecessary checks~\cite{alsahafy2020computing,hespe2019scalable}.
In comparison, efforts to improve other aspects of branch-and-reduce are still lacking.
However, the branching strategy in particular has been shown to have a significant impact on the running time~\cite{AkibaIwata}.
Up to now, the most frequently used branching strategy employed in many state-of-the-art solvers selects branching vertices solely based on their degree.
Other factors, such as the actual reduction rules used during the algorithm are rarely taken into account.
However, recently there have been some attempts to incorporate such branching strategies for other problems such as $k$-plexes~\cite{gao2018exact}.

\subsection{Contribution}
In this paper, we propose and examine several novel strategies for selecting branching vertices.
These strategies follow two main approaches that are motivated by existing research: (1) Branching on vertices that decompose the graph into several connected components that can be solved independently.
This has been shown to significantly improve the performance of branch-and-reduce in practice, especially when the size of the largest component is kept small~\cite{alsahafy2020computing}.
(2) Branching on vertices whose removal leads to reduction rules becoming applicable again.
In turn, this leads to a smaller reduced graph and thus improved performance.
For each approach we present several concrete strategies that vary in their complexity.
Finally, we evaluate their performance by comparing them to the aforementioned default strategy used in the state-of-the-art solver by Akiba and Iwata~\cite{AkibaIwata}.
For this purpose we make of a wide spectrum of instances from different graph classes and applications.
Our experiments indicate \ldots \todo{add some experimental data}.
A more detailed explanation of a previous version of this work
can be found in Schorr's Bachelor Thesis~\cite{schorr2020improved}.

\section{Preliminaries}
Let $G=(V,E)$ be an undirected graph, where $V = \{0, \ldots, n-1\}$ is a set of $n$ vertices and $E \subseteq  \{\{u,v\} \mid u,v \in V\}$ is a set of $m$ edges. 
We assume that $G$ is \emph{simple}, \ie it has no self loops or multi-edges.
The \emph{(open) neighborhood} of a vertex $v \in V$ is denoted by $N(v) = \{u \mid \{v,u\} \in E\}$.
Furthermore, we denote the \emph{closed neighborhood} of a vertex by $N[v]=N(v) \cup \{v\}$.
We define the open and closed neighborhood of a set of vertices $U \subseteq V$
as $N(U) = \cup_{u \in U} N(v) \setminus U$ and $N[U] = N(U) \cup U$, respectively.
The \emph{degree} of a vertex $v \in V$ is the size of its neighborhood $d(v) = |N(v)|$.
For a vertex $v \in V$, we further define $N^2(v) = N(N(v))$.

For a subset of vertices $V_S \subseteq V$, the \emph{(vertex-)induced subgraph}
$G[V_S] = (V_S, E_S)$ is given by restricting the edges of $G$ to vertices of $V_S$, \ie $E_S = \{\{u,v\} \in E \mid u,v \in V_S\}$.
Likewise, for a subset of edges $E_S \subseteq E$, the \emph{edge-induced
  subgraph} $G[E_S] = (V_S, E_S)$ is given by restricting the vertices of $G$ to the endpoints of edges in $E_S$, \ie $V_S = \{u \in V \mid \{u,v\} \in E_S\}$.
  For a subset of vertices $U \subset V$, we further define $G - U$ as the induced subgraph $G[V \setminus U]$.

A \emph{path} $P=(v_1, \ldots, v_k)$ of length $k$ is a sequence of $k$ distinct vertices in $G$ such that $\{v_i, v_{i+1}\} \in E$ for all $i \in \{1, \ldots, k-1\}$.
A subgraph of $G$ induced by a maximal subset of vertices that are connected by a path is called a \emph{connected component}.
Furthermore, a graph that only contains one connected components is called \emph{connected}.
Likewise, a graph with more than one connected component is called \emph{disconnected}.
A subset $S \subset V$ of a connected graph $G$ is called a \emph{vertex separator}, if the removal of $S$ from $G$ makes the graph disconnected.

An \emph{independent set} of a graph is a subset of vertices $I \subseteq V$ such that no two vertices of $I$ are adjacent. 
A \emph{maximum independent set} (MIS) is an independent set of maximum cardinality.
Closely related to independent set are vertex covers and cliques.
A \emph{vertex cover} is a set of vertices $C \subseteq V$ such that for each edge $\{u,v\} \in E$ either $u$ or $v$ is contained in $C$.
The complement of a (maximum) independent set of a graph $G$ is a \emph{(minimum) vertex cover} (MVC) of $G$.
A \emph{clique} is a subset of vertices $K \subseteq V$ such that all vertices of $K$ are adjacent to each other, \ie $\forall u,v \in K: \{u,v\} \in E$.
Finally, a (maximum) independent set of a graph $G$ is a \emph{(maximum) clique} (MC) in the complement graph $\bar{G} = (V, \bar{E})$, where $\bar{E} = \{\{u,v\} \mid \{u,v\} \not\in E\}$.

\section{Related Work}
Selecting branching vertices is a part of every branch-and-reduce or
branch-and-bound algorithm. In this section we give an overview of the techniques used in
algorithms for MIS, MVC and MC.

The most commonly used branching strategy for MIS and MVC is to select a vertex
of maximum degree. Fomin et al.~\cite{Fomin} show that using a vertex of maximum
degree that also minimizes the number of edges between its neighbors is optimal
with respect to their complexity measure. The Algorithm by Akiba and Iwata~\cite{AkibaIwata}
(which we use for our experiments) also uses this strategy. Akiba and Iwata also
compare this strategy to branching on a vertex of minimum degree and a random
vertex. They show that both of these perform significantly worse than branching
on a maximum degree vertex.

Xiao and Nagamochi~\cite{XiaoNagamochi} also use
this strategy in most cases. For dense subgraphs, however, they use an edge
branching strategy: They branch on an edge $\{u, v\}$ where $|N(u) \cap N(v)|$
is sufficiently large (depending on the maximum degree of the graph) by
excluding both $u$ and $v$ in one branch and applying the alternative reduction
(see Section~\ref{sec:almost_funnels}) to $\{u\}$ and $\{v\}$ in the other branch.

Buurgeois et al.~\cite{Bourgeois} use maximum degree branching as long as the
average degree of the graph is above 4. Otherwise, if there is no vertex with degree of at least 5, their algorithm branches on vertices
contained in 3- or 4-cycles. \todo{@Christian weißt du auch, was
passiert, wenn es Knoten mit höherem Grad gibt?}

Chen et al.~\cite{ChenXiaKanj} use a notion of \emph{good pairs} that are advantageous
for branching. They chose these good pairs by a set of rules which are omitted
here. They combine these with so-called \emph{tuples} of a set of vertices and the
number of vertices from this set that have to be included in an MIS. This
information can be used when branching on a vertex
contained in that set to remove further vertices from the graph. Akiba and
Iwata~\cite{AkibaIwata} use the same concept in their \emph{packing} rule. Chen
et al. combine good pairs, tuples and high degree vertices for their branching strategy.

Most algorithms for MC (e.g. San Segundo and Tapia~\cite{Color}) compute a
greedy coloring and branch on vertices with a high coloring number.
More sophisticated MC algorithms use MaxSAT encodings to prune the set of
branching vertices~\cite{LiFangXu,LiJiang,LiQuan}. Li et al.~\cite{LiMaxSat}
combine greedy coloring and MaxSAT reasoning the further reduce the number of
branching vertices.

Another approach used for MC is using the \emph{degeneracy order} $v_1 < v_2 <
\dots < v_n$ where $v_i$ is a vertex of smallest degree in $G - \{v_1, \dots
v_{i-1}\}$. Carraghan and Pardalos~\cite{CarraghanPardalos} present an algorithm
that branches in descending degeneracy order. Li et al.~\cite{LiFangXu}
introduce another vertex ordering using iterative maximum independent set
computations (which might be easier than MC on some graphs) and breaking ties
according to the degeneracy order.

\subsection{Branch and Reduce Algorithm by Akiba and Iwata~\cite{AkibaIwata}}

The algorithm by Akiba and Iwata~\cite{AkibaIwata} is a so called
\emph{branch-and-reduce} algorithm: It repeatedly reduces the instance size by a
set of polynomial time reduction rules and then branches on a vertex once no
more reduction rules can be applied. Since branching removes at least one vertex
from the graph, more reduction rules might be applicable afterwards. The
reduction set used in their algorithm is relatively large and not covered
completely here. However, some reduction rules are explained in
Section~\ref{sec:reduction_branching} where we show how to target a particular reduction
rules when branching. The reduction rules are applied by iterating over all
vertices in the graph once for each rule and checking whether the rule
can be applied to each vertex. In order to prune the search space, bounds on the largest
possible independent set of a branch are computed. They implement three different
methods for determining upper bounds: clique cover, LP relaxation and cycle
cover. Additionally, they employ special reduction rules that can be applied
during branching. Another optimization done by their algorithm is to solve
connected components separately. We utilize this in
Section~\ref{sec:decomposition_branching} where we introduce branching rules
that decompose the graph into connected components. Akiba and Iwata also
compare three different strategies for
selecting the branching vertex: Uniform random, minimum degree and maximum
degree. They conclude that choosing a vertex of maximum degree that also
minimizes the number of edges among $N(v)$ performs best. We use this algorithm
as the base implementation to test our new branching strategies.
\todo{Maybe give outline with pseudocode? }

\section{Decomposition Branching}
\label{sec:decomposition_branching}
Our first approach to improve the default branching strategy found in many state-of-the-art algorithms (including that of Akiba and Iwata~\cite{AkibaIwata}) is to decompose the graph into several connected components.
Subsequently processing these components individually has been shown to improve the performance of branch-and-reduce in practice~\cite{alsahafy2020computing}.
To this end, we now present three concrete strategies with varying computational complexity.

\subsection{Articulation Points}
First, we are concerned with finding single vertices that are able to decompose a graph into at least two separated components.
Such points are called \emph{articulation points} (or cut vertices).
Articulation points can be computed in linear time $\mathcal{O}(n+m)$ using a simple depth-first search (DFS) algorithm.
In particular, a vertex $v$ is an articulation point if it is either the root of
the DFS tree and has at least two children or any non-root vertex that has a child $u$, such that no vertex in
the subtree rooted at $u$ has a backwards edge to one of the ancestors of
$v$.

For our first branching strategy we maintain a set of articulation points $A \subseteq V$.
When selecting a branching vertex, we first discard all invalid vertices from $A$, \ie vertices that were removed from the graph by a preceding kernelization step.
If this results in $A$ becoming empty, a new set of articulation points is computed on the current graph in linear time.
However, if no articulation points can be found, we select a vertex based on the default branching strategy.
In this case, we skip computing new articulation points for a fixed number of branching steps, since it is seems unlikely that new ones are found in the following iterations.
Otherwise, if $A$ contains at least one vertex, a random one from $A$ selected as the branching
vertex. Figure~\ref{fig:articulation_points} illustrates branching on an
articulation point.

\begin{figure}[t]
  \centering
  \includegraphics[scale=1]{figures/articulation_points}
  \caption{Branching on an articulation point (circled vertex) the
    graph decomposes into two connected components (gray boxes) that can be
    solved independently. The graphic show the branch on which the vertex is
    excluded from the independent set.}
  \label{fig:articulation_points}
\end{figure}

Even tough this strategy yields only a small (linear) overhead, finding articulation points can be rare depending on the type of graph.
This results in the default branching strategy being selected rather
frequently.
Furthermore, our preliminary experiments indicated that articulation points are rarely found at higher depth.
Thus, we limit the maximum depth at which we search for articulation points.

\subsection{Edge Cuts}
To alleviate the restrictive nature of finding articulation points, we now propose a more flexible branching strategy based on \emph{(minimal) edge cuts}.
In general, we still aim to find small vertex separators, \ie a set of vertices whose removal disconnects the graph.
We do so by making use of minimum edge cuts.

A \emph{cut} $(S,T)$ is a partitioning of $V$ into two sets $S$ and $T=V\setminus S$.
Furthermore, a cut is called minimum if its \emph{cut set} $C = \{\{u,v\} \in E \mid u \in S, v \in T\}$ has minimal cardinality.
However, in practice, finding minimum cuts often yields trivial cuts with either $S$ or $T$ only consisting of a single vertex with minimum degree. 
Thus, we are interested in finding \emph{$s$-$t$-cuts}, \ie cuts where $S$ and $T$ contain specific vertices $s,t \in V$.
Finding these cuts can be done efficiently in practice, \eg using a preflow push algorithm~\cite{goldberg1988new}.
However, selecting the vertices $s$ and $t$ to ensure reasonably balanced cuts can be tricky.
Natural choices include random vertices, as well as vertices that are far apart in terms of their shortest path distance.
However, our preliminary experiments indicate that selecting random vertices of maximum degree
 for $s$ and $t$ seems to produce the best results.
Finally, to derive a vertex separator from a cut one can compute an MVC on the bipartite graph induced by the cut set, \eg using the Hopcroft-Karp algorithm~\cite{hopcroft1973n}.
This separator can then be used to select branching vertices.

Overall, our second strategy works similar to the first one: We maintain a set of possible branching vertices that were selected by computing a minimum $s$-$t$-cut and turning it into a vertex separator.
Vertices that were removed by kernelization are discarded from this set and once it is empty, a new cut computation is started.
However, in contrast to the first strategy finding a set of suitable branching vertices is much more likely.
In order to avoid separators that contain too many vertices, and thus would require too many branching steps to disconnect the graph, we only keep those that do not exceed a certain size and balance threshold.
The specific values for these threshold are presented in Section~\ref{sec:algo_conf}.
Finally, if no suitable separator is found, we use the default branching strategy.
Furthermore, in this case we do not try to find a new separator for a fixed number of branching steps as finding one is both unlikely and costly.

\subsection{Nested Dissection}
Both of our previous strategies dynamically maintain a set of possible branching vertices.
Even though this comes at the advantage that most of the computed vertices remain viable candidates for some branching steps, it introduces a noticeable overhead.
To alleviate this, our last strategy uses a static ordering of possible branching vertices that is computed once at the beginning of the algorithm.
For this purpose we make use of a \emph{nested dissection ordering}~\cite{george1973nested}.

A nested dissection ordering of the vertices of a graph $G$ is obtained by recursively computing balanced bipartitions $(A,B)$ and a vertex separator $S$, that separates $A$ and $B$.
The actual ordering is then given by concatenating the orderings of $A$ and $B$ followed by the vertices of $S$.
Thus, if we select branching vertices based on the reverse nested dissection
ordering, we continuously branch on vertices that disconnect the graph into balanced partitions. 
We compute such an ordering once, after finishing the initial kernelization phase.

There are two main optimizations that we use when considering the nested dissection ordering.
First, we noticed that vertices at the end of the ordering seldom lead to a decomposition of the graph. 
This is due to vertices being removed by kernelization which can lead to separators becoming invalid.
Thus, we limit the number of recursive calls during the nested dissection computation.
Furthermore, similar to the edge cut based strategy, we limit the size of
separators considered during branching using a threshold.
Again, this is done to ensure that we do not require too many branching steps to decompose the graph.
The specific value for this size threshold is given in Section~\ref{sec:algo_conf}.
If any separator in the nested dissection exceeds this threshold, we use the default branching strategy.

\section{Reduction Branching}
\label{sec:reduction_branching}
Our second approach to selecting good branching vertices is to choose a vertex
whose removal will enable the application of new reduction rules. During every
reduction step we find a list of candidate vertices to branch on. The following
sections will demonstrate how we identify such branching candidate vertices with little
computational overhead in practice. To be self contained we will also repeat the reduction
rules used here but omit any proofs that can be found in the original
publications. Out of the candidates found we then select a vertex of
maximum degree. If the degree of all candidate vertices lies below a threshold
(defined in Section~\ref{sec:algo_conf}) or no candidate vertices were found we fall back to branching on a vertex
of maximum degree. The rational here is that a vertex of large degree changes
the structure of the graph more than a vertex of small degree even if that
vertex is guaranteed to enable the application of a reduction rule. Also, our
current strategies only enable the application of the targeted reduction rule in
the branch that excludes the vertex from the independent set. However, in the
case that includes it into the independent set all neighbors are removed from
the graph as well because they already have an adjacent vertex in the solution.

We also did some preliminary experiments with storing the candidate vertices in
a priority queue across branch-reduce steps and updating that list continually.
However, changes where too frequent for this approach to be faster because of
the high amount of priority queue operations compared to the relatively low overhead
caused by the current approach.

\subsection{Almost Twins}

The first reduction we target is the \emph{twin} reduction by Xiao and Nagamochi~\cite{XiaoUnconfined}:

\begin{definition}(Twins~\cite{XiaoUnconfined})
  In a graph $G=(V,E)$ two vertices $u$ and $v$ are called twins, if $N(u) = N(v)$ and $d(u) = d(v) = 3$.
\end{definition}

\begin{theorem} (Twin Reduction~\cite{XiaoUnconfined}) In a graph $G=(V,E)$ let
  vertices $u$ and $v$ be twins. If there is an edge among $N(u)$, then there is
  always an MIS that includes $\{u,v\}$ and therefore
  excludes $N(u)$. Otherwise, let $G'=(V',E')$ be the graph with $V'=(V\setminus
  N[\{u,v\}])\cup\{w\}$ where $w\notin V$ and $E'=(E\cap\binom{V'}{2})\cup
  \{\{w,x\}\;|\;x\in N^2(u)\})\}$ and let $I'$ be an MIS in $G'$. Then, 
  $
  I=\begin{cases}
    I'\cup \{u,v\} & \text{, if }w\notin I'\\
    (I'\setminus \{w\})\cup N(u) & \text{, else} %w\in I'
  \end{cases}
  $
  is an MIS in $G$.
\end{theorem}

We now define \emph{Almost Twins} as follows:
\begin{definition} (Almost Twins)
  In a graph $G=(V,E)$ two non adjacent vertices $u$ and $v$ are called almost twins if $d(u) = 4$, $d(v) = 3$ and $N(v)\subseteq N(u)$ (\ie $N(u) = N(v) \cup \{w\}$). 
\end{definition}

Clearly, after removing $w$, $u$ and $v$ are twins so we can apply the twin
reduction. Finding almost twins can be done while searching for twins: The
original algorithm checks for each vertex $v$ of degree $3$ whether there is a
vertex $u \in N^2(v)$ which $d(u) = 3$ and $N(u) = N(v)$. We augment this
algorithm by simultaneously also searching for $u \in N^2(v)$ with $d(u) = 4$
and $N(v) \subset N(u)$. This induces about the same computational cost for
degree $4$ vertices in $N^2(v)$ as for degree $3$ vertices. While there might be
instances where this causes high overhead, we expect the practical slowdown to
be small. Figure~\ref{fig:twin} illustrates branching for almost twins. 

\begin{figure}[t]
  \centering
  \includegraphics[scale=1]{figures/twin}
  \caption{The two solidly circled vertices are almost twins. After branching on
  the dashed circled vertex they become twins (in the excluding branch) and can
  be reduced.}
  \label{fig:twin}
\end{figure}

\subsection{Almost Funnels}
\label{sec:almost_funnels}

Next we consider the \emph{funnel} reduction which is a special case of the
\emph{alternative} reduction by Xiao and Nagamochi~\cite{XiaoUnconfined}:

\begin{definition} (Alternative Sets~\cite{XiaoUnconfined})
	In a graph $G=(V,E)$ two non empty, disjoint subsets $A,B\subseteq V$ are
    called alternatives, if $|A| = |B|$ and there is an MIS $I$ in $G$ such that $I\cap(A\cup B)$ is either $A$ or $B$.
\end{definition}

\begin{theorem} (Alternative Reduction~\cite{XiaoUnconfined})
	In a graph $G=(V,E)$ let $A$ and $B$ be alternative sets. Let $G'=(V', E')$
    the graph with $V' = V\setminus(A\cup B\cup (N(A)\cap N(B)))$ and $E' =
    \{\{u,v\} \in E \mid u,v \in V'\} \cup \{ \{u,v\}\;|\; u\in
    N(A)\setminus N[B], v\in N(B)\setminus N[A] \}$ and let $I'$ be an MIS in $G'$. Then,
	$
    I=\begin{cases}
      I'\cup A & \text{, if } (N(A)\setminus N[B]) \cap I' = \emptyset% N(B)\setminus N[A]\subseteq I'\\
      \\
      I'\cup B & \text{, else}
	\end{cases}
    $
	is an MIS in $G$.
\end{theorem}

Note that the alternative reduction adds new edges between existing
vertices of the graph which might not be beneficial in every case. To counteract this, the algorithm
by Akiba and Iwata~\cite{AkibaIwata} only uses special cases, one of which is
the funnel reduction:

\begin{definition} (Funnel~\cite{XiaoUnconfined})
	In a graph $G=(V,E)$ two adjacent vertices $u$ and $v$ are called funnels, if $G_{N(v)\setminus\{u\}}$ is a complete graph, i.e, if $N(v)\setminus\{u\}$ is a clique.
\end{definition}
\begin{theorem} (Funnel Reduction~\cite{XiaoUnconfined}) In a graph $G=(V,E)$ let $u$ and $v$ be funnels. Then, $\{u\}$ and $\{v\}$ are alternative sets.	
\end{theorem}

Again, we define a structure that is covered by the funnel reduction after
removal of a single vertex:

\begin{definition}(Almost Funnel)
  In a graph $G=(V,E)$ two adjacent vertices $u$ and $v$ are called almost funnels if $u$ and $v$ are not funnels and there is a vertex $w$ such that $N(v)\setminus\{u,w\}$ induces a clique.
\end{definition}

By removing $w$, $u$ and $v$ become funnels. The original funnel algorithm
checks whether $u$ and $v$ are funnels by iterating over the vertices in $N(v) \setminus \{u\}$
and checking whether they are adjacent to \emph{all} previous vertices. Once a vertex
is found that is not adjacent to all previous vertices, the algorithm concludes
that $u$ and $v$ are not funnels and terminates. We augment this algorithm by
not immediately terminating in this case. Instead, we consider the following two
cases: Either the current vertex $w$ is not adjacent to at least two of the
previous vertices. In this case, we can check whether $N(v) \setminus \{u, w\}$
induces a clique. In the second case, $w$ is adjacent to all but one previous
vertex $w'$. In this case, both $w$ and $w'$ might be candidate branching
vertices. Thus, we check whether $N(v) \setminus \{u, w\}$ or $N(v) \setminus
\{u, w'\}$ induce a clique. This adds up to two additional clique checks (of
slightly smaller size) to the one clique check in the original algorithm.

% \subsection{Almost Dominance}
% \label{sec:almost_dominance}

% The next branching strategy is based on the dominance reduction rule by Fomin et al.~\cite{Fomin}:

% \begin{definition} (Dominance~\cite{Fomin})
%   In a graph $G=(V,E)$ a vertex $u$ is called dominated by a neighbor $v$, if $N[u]\subseteq N[v]$.
% \end{definition}

% \begin{theorem} (Dominance Reduction~\cite{Fomin}) In a graph $G=(V,E)$, if a
%   vertex $u$ is dominated by a neighbor $v$, then, there always exists an MIS that does not include $v$, i.e.~$\alpha(G)=\alpha(G-\{v\})$
% \end{theorem}

% A vertex is almost dominated by one of it has only one surplus neighbor:

% \begin{definition} (Almost Dominance)
%   In a graph $G=(V,E)$ a vertex $u$ is called almost dominated by a neighbor $v$ if $|N(u)\setminus N(v)| = 1$ and $N[v]\not\subseteq N(u)$.
% \end{definition}
%  The last condition ensures that $v$ is not dominated by $u$. The original
%  algorithm checks for each neighbor of $u$ is also a neighbor of $v$. Once it
%  finds a vertex in $N(u)$ that is not in $N(v)$, it terminates because $u$ can not
%  be dominated by $v$. We augment this algorithm by allowing a single vertex $w
%  \in N(u)$ that is not adjacent to $v$ and adding $w$ as a candidate branching
%  vertex if it exists. If $w$ is found early in the algorithm, this might induce
%  some overhead to the algorithm but assuming the position of $w$ in $u$'s
%  adjacency list to be uniformly randomly distributed, the expected number of
%  vertices to check only doubles.

%  Note that the dominance reduction is not directly used in the Algorithm by
%  Akiba and Iwata~\cite{AkibaIwata} because it is fully contained in the unconfined
%  reduction (see Section~\ref{sec:almost_unconfined}). This means that we cannot
%  simply search for almost dominated vertices during the reduction step. Instead,
%  we have to do an additional pass over all vertices.
 
\subsection{Almost Unconfined}
\label{sec:almost_unconfined}

% The \emph{unconfined} reduction by Xiao and Nagamochi~\cite{XiaoNagamochi} is a generalization of the dominance reduction
% (see Section~\ref{sec:almost_dominance}).
The core idea of the \emph{unconfined} reduction by Xiao and
Nagamochi~\cite{XiaoUnconfined} is to detect vertices not required for an MIS
that can therefore can be removed from the graph by algorithmically
contradicting the assumption that every MIS contains the vertex.

\begin{definition} (Removable Vertex~\cite{XiaoUnconfined})
	In a graph $G=(V,E)$ a vertex $v$ is called removable, if 
	$\alpha(G) = \alpha(G-\{v\})$.
\end{definition}

\begin{definition} (Child, Parent~\cite{XiaoUnconfined}) In a graph $G=(V,E)$ with an \textit{independent set} $I$, a vertex $v$ is called a child of $I$, if $|N(v)\cap I| = 1$ and the unique neighbor of $v$ in $I$ is called the parent of $v$.
\end{definition}

\begin{theorem} (\cite{XiaoUnconfined})\label{theorem:unconfined}
	In a graph $G=(V,E)$ let $S$ be an independent set that is not maximal but is contained in every MIS of $G$ and let $v$ be any child of $S$. Then, every MIS includes at least one vertex from $N(v)\setminus N[S]$.
\end{theorem}

Based on Theorem \ref{theorem:unconfined} Algorithm \ref{alg:unconf} detects so called \textit{unconfined} vertices.

\begin{algorithm}[t]
	\caption{Unconfined -- Xiao and Nagamochi
      \cite{XiaoUnconfined}}\label{alg:unconf}
	\SetKwFunction{U}{Unconfined}
	\DontPrintSemicolon
	
	\KwIn{A graph $G$, a vertex $v$}
	\U{G, v}	
	\Begin{
		$S \leftarrow \{v\}$\;
		\While{$S\text{ has child }u\text{ with } |N(u)\setminus N[S]|\leq 1$}{
			\eIf{$|N(u)\setminus N[S]| = 0$}{\Return true\tcp*{contradiction to Theorem \ref{theorem:unconfined}}}{
				$\{w\}\leftarrow N(u)\setminus N[v]$\tcp*{by assumption $w$ also has to}
				$S\leftarrow S\cup\{w\}$\tcp*{be contained in every MIS}
			}
		}
		
		\Return $\text{false}$
		
	}
	
	\KwOut{true if $v$ is unconfined, false otherwise}
	
\end{algorithm}


\begin{theorem}(Unconfined Reduction~\cite{XiaoUnconfined}) In a graph $G=(V,E)$,
  if Algorithm \ref{alg:unconf} returns true for an unconfined vertex $v$, then
  there is always an MIS that does not contain~$v$.
\end{theorem}\todo{Wenn wir Platzprobleme haben, können wir auch nur den Algo
  und dieses Theorem behalten}

Again, we define a vertex to be almost unconfined:

\begin{definition} (Almost Unconfined)
  In a graph $G=(V,E)$ a vertex $v$ is called almost unconfined if $v$ is not unconfined but there is a vertex $w$ such that $v$ is unconfined in $G-\{w\}$.
\end{definition}

Here, we only present an augmentation that detects \emph{some} almost
unconfined vertices. In particular, if at any point during the algorithm there
is only \emph{one} extending child, i.e. a child $u$ of $S$ with $N(u)\setminus
N[S] = \{w\}$, then removal of $w$ makes $v$ unconfined. During
Algorithm~\ref{alg:unconf} we collect all these vertices $w$ and add them to the
set of candidate branching vertices if the algorithm cannot already remove $v$.
This only adds the overhead of temporarily storing the potential candidates and
adding them to the actual candidate list if $v$ is not removed.

% Note that this special case of almost unconfined vertices might not catch all
% cases of almost dominated vertices.

\section{Experimental Evaluation}

In this section we present the results of our experimental evaluation. Tables
and figures here show aggregated results. For
detailed results for all of our algorithms across all instances, see Appendix~\ref{app:detailed_results}.

\subsection{Experimental Environment}
We execute all our experiments on a machine with 4 8-core Intel Xeon E5-4640 CPUs
(2.4~GHz) and 512 GiB DDR3-PC1600 RAM. To speed up our experiments we use two
identical machines and run \textcolor{red}{X}\todo{@Christian: How many} instances at once on the
same machine (using the same machine for all algorithms on a specific instance).
All numbers reported are averages \todo{@Christian or means?} of three runs with
a timeout of \textcolor{red}{X}\todo{@Christian: fill in} hours.

\subsection{Algorithm Configuration}
\label{sec:algo_conf}
We use a C++ adaptation of the implementation by Akiba and
Iwata~\cite{AkibaIwata} in its default configuration\todo{@Christian: Is this
  true?} as a basis for our algorithm. During preliminary experiments we found
suitable values for the parameters of
our techniques. These experiments were run on a subset of our total instance
set. We use the geometric mean over all instances of the speedup over the
default branching strategy as a basis for our decision: The number of branching
steps skipped after an unsuccessful search for articulation points is set
to \textcolor{red}{X}\todo{@Christian: fill in}. For the technique based on
s-t-cuts, we only use cuts that contain at most
\textcolor{red}{X}\todo{@Christian: fill in} vertices and where the smaller side of
the cut contains at least \textcolor{red}{X}\todo{@Christian: fill in} vertices.
If no suitable separator is found, we skip \textcolor{red}{X}\todo{@Christian:
  fill in} branching steps. For computing nested dissections, we use 
InertialFlowCutter\footnote{\url{https://github.com/kit-algo/InertialFlowCutter}}
with the KaHIP\footnote{\url{https://kahip.github.io/}}
backend.\todo{@Christian: Add parameters for this.} For branching we use
\textcolor{red}{X}\todo{@Christian: fill in} levels of nested dissections and
only use the nested dissection if separators contain at most
\textcolor{red}{X}\todo{@Christian: fill in} vertices. For the reduction based
branching rules, we fall back to the default branching strategy if all
candidates have a degree of less than \textcolor{red}{X}\todo{@Christian: fill in}.

\subsection{Instances}
We use instances from several sources: A sample of the instances used for the
PACE 2019 Challenge on Minimum Vertex Cover~\cite{dzulfikar_et_al:LIPIcs:2019:11486}. Maximum Clique instances from the second
DIMACS Implementation Challenge~\cite{johnson1993cliques} and sparse instances from
the Stanford Network Analysis Project (SNAP)~\cite{snapnets}\todo{@Christian:
  Ich kann hier nicht alle Graphen aus der Liste finden. Außerdem: Muss man für
  die Instanzen noch andere Sachen zitieren?}.\todo{road networks mit Quelle?} Detailed instance information can
be found in Appendix~\ref{app:instances}.\todo{@Christian: Add table of
  instances with num. vertices and edges.}

\subsection{Decomposition Branching}
\label{sec:experiments_decomp}

\todo{@Sebastian: Da decomposition based so schlecht funktioniert, sollten wir
  vielleicht im Hauptteil und hier die beiden Ansätze tauschen?}
Figure~\ref{fig:all_decomp_time} shows a perfomance plot of the running time of
our decomposition based branching strategies: For each instance, the best
algorithm is determined. The plot shows for each algorithm $1$ minus the time of the best algorithm
divided by the time the respective algorithm took. So a value of $0$ means that
the algorithm was the fastest algorithm on that instance and a value of
$\numprint{0.5}$ means that the algorithm took twice as long as the fastest
algorithm. Timeouts are shown as a value $> 1$. For each algorithm, instances
are then sorted by their value. Note that this means that the points on a
vertical line do not correspond to the same instance.

The plot shows that for most instances, the default strategy of branching on a
vertex of maximum degree outperforms our decomposition based approaches.
However, there is one instance\todo{Update after full results are in} (web-stanford) that causes a timeout with the
default strategy but can be solved in $48$\todo{Update after full results are in} (articulation points) to $176$\todo{Update after full results are in} (nested
dissections) seconds using a decomposition based approach. Accounting a time of
\textcolor{red}{timeouttime}\todo{insert timeout} for the default strategy on
this instance, this results in a geometric mean speedup of about two for all
decomposition based techniques on the SNAP instances (see Table~\ref{tab:summary_decomp}).\todo{@christian:
  Interpretiere ich diese Zahl richtig?} Overall, most running
times are only slightly slower than the default strategy. This is mainly because
the number of branches required to solve the instances does not change in most
cases (see Figure~\ref{fig:all_decomp_branch}) and most of the running time
difference is caused by the overhead from
searching for branching vertices. Table~\ref{tab:summary_decomp} \dots\todo{write
  something about the table}

\begin{table}[t]
  \caption{Speedup of our decomposition based techniques over the default
    strategy (max. degree). ``all'' are geometric means of the speedup over all
  instances of that type (timeouts are assigned a running time of
  \textcolor{red}{timeouttime} hours), ``solved'' are geometric means of the
  speedup over all instances that have been solved by all techniques.}
\label{tab:summary_decomp}

  \centering
  \begin{tabular}{|l|rr|rr|rr|rr|}
    \hline
    Instance type $\rightarrow$ & \multicolumn{2}{c|}{PACE} & \multicolumn{2}{c|}{DIMACS} & \multicolumn{2}{c|}{SNAP} & \multicolumn{2}{c|}{All Instances}                                                                                                          \\
    technique $\downarrow$      & \multicolumn{1}{c}{all}   & \multicolumn{1}{c|}{solved} & \multicolumn{1}{c}{all}   & \multicolumn{1}{c|}{solved} & \multicolumn{1}{c}{all} & \multicolumn{1}{c|}{solved} & \multicolumn{1}{c}{all} & \multicolumn{1}{c|}{solved} \\
    \hline
    articulation points         & \textcolor{red}{TODO}     & \textcolor{red}{TODO}       & \textcolor{red}{TODO}     & \textcolor{red}{TODO}       & \textcolor{red}{TODO}   & \textcolor{red}{TODO}       & \textcolor{red}{TODO}   & \textcolor{red}{TODO}       \\
    st-cuts                     & \textcolor{red}{TODO}     & \textcolor{red}{TODO}       & \textcolor{red}{TODO}     & \textcolor{red}{TODO}       & \textcolor{red}{TODO}   & \textcolor{red}{TODO}       & \textcolor{red}{TODO}   & \textcolor{red}{TODO}       \\
    nested dissections          & \textcolor{red}{TODO}     & \textcolor{red}{TODO}       & \textcolor{red}{TODO}     & \textcolor{red}{TODO}       & \textcolor{red}{TODO}   & \textcolor{red}{TODO}       & \textcolor{red}{TODO}   & \textcolor{red}{TODO}       \\
    \hline
    \end{tabular}
\end{table}

\begin{figure}[t]
\includegraphics[width=\textwidth]{plots/all_decomposition_based_time}
\caption{Performance plot comparing running times of decomposition based branching strategies.}
\label{fig:all_decomp_time}
\end{figure}

\begin{figure}[t]
  \includegraphics[width=\textwidth]{plots/all_decomposition_based_branch}
  \caption{Performance plot comparing branches of decomposition based branching strategies.}
  \label{fig:all_decomp_branch}
\end{figure}


\subsection{Reduction Branching}
Figure~\ref{fig:all_reduction_time} shows the performance plot (see
Section~\ref{sec:experiments_decomp}) for our reduction
based branching strategies. Here we see that targeting the funnel reduction
results in the fastest time for the most number of instances. In fact, the
funnel based technique is the fastest for all but 9 of the PACE instances. The
default strategy is only fastest for 4 of these instances. However, all
reduction based strategies fail to solve instance 40 of the PACE dataset which
the default strategy solves in about 7 hours\todo{update with final number}.
Interestingly, when targeting the funnel reduction, PACE instance 36 times out
but can be solved in 10 to 83 seconds\todo{update numbers} with all other
strategies. We also show results for a strategy that targets all reduction rules
described in Section~\ref{sec:reduction_branching}. Even though this approach
leads to the lowest number of branches for most instances (see Figure~\ref{fig:all_reduction_branch}), the time required to
identify candidate vertices for all reduction rules causes too big of an
overhead to be competitive. Optimizing the algorithms to identify candidate
vertices could lead to making this combined strategy
dominant. Table~\ref{tab:summary_reduction} \dots\todo{write
  something about the table}

\begin{table}[t]
  \caption{Speedup of our reduction based techniques over the default
    strategy (max. degree). ``all'' are geometric means of the speedup over all
  instances of that type (timeouts are assigned a running time of
  \textcolor{red}{timeouttime} hours), ``solved'' are geometric means of the
  speedup over all instances that have been solved by all techniques.}
\label{tab:summary_reduction}

  \centering
  \begin{tabular}{|l|rr|rr|rr|rr|}
    \hline
    Instance type $\rightarrow$ & \multicolumn{2}{c|}{PACE} & \multicolumn{2}{c|}{DIMACS} & \multicolumn{2}{c|}{SNAP} & \multicolumn{2}{c|}{All Instances}                                                                                                          \\
    reduction rule $\downarrow$ & \multicolumn{1}{c}{all}   & \multicolumn{1}{c|}{solved} & \multicolumn{1}{c}{all}   & \multicolumn{1}{c|}{solved} & \multicolumn{1}{c}{all} & \multicolumn{1}{c|}{solved} & \multicolumn{1}{c}{all} & \multicolumn{1}{c|}{solved} \\
    \hline
    Twin                        & \textcolor{red}{TODO}     & \textcolor{red}{TODO}       & \textcolor{red}{TODO}     & \textcolor{red}{TODO}       & \textcolor{red}{TODO}   & \textcolor{red}{TODO}       & \textcolor{red}{TODO}   & \textcolor{red}{TODO}       \\
    Funnel                      & \textcolor{red}{TODO}     & \textcolor{red}{TODO}       & \textcolor{red}{TODO}     & \textcolor{red}{TODO}       & \textcolor{red}{TODO}   & \textcolor{red}{TODO}       & \textcolor{red}{TODO}   & \textcolor{red}{TODO}       \\
    Unconfined                  & \textcolor{red}{TODO}     & \textcolor{red}{TODO}       & \textcolor{red}{TODO}     & \textcolor{red}{TODO}       & \textcolor{red}{TODO}   & \textcolor{red}{TODO}       & \textcolor{red}{TODO}   & \textcolor{red}{TODO}       \\
    Combined                    & \textcolor{red}{TODO}     & \textcolor{red}{TODO}       & \textcolor{red}{TODO}     & \textcolor{red}{TODO}       & \textcolor{red}{TODO}   & \textcolor{red}{TODO}       & \textcolor{red}{TODO}   & \textcolor{red}{TODO}       \\
    \hline
    \end{tabular}
\end{table}

\begin{figure}[t]
  \includegraphics[width=\textwidth]{plots/all_reduction_based_time}
  \caption{Performance plot comparing running time of reduction based branching strategies.}
  \label{fig:all_reduction_time}
\end{figure}

\begin{figure}[t]
  \includegraphics[width=\textwidth]{plots/all_reduction_based_branch}
  \caption{Performance plot comparing branches of reduction based branching strategies.}
  \label{fig:all_reduction_branch}
\end{figure}


\section{Conclusion and Future Work}

%%
%% Bibliography
%%

\FloatBarrier
%% Please use bibtex, 
\todo{TODO: Before submitting check for all references whether they are actually used in the text}
\bibliography{references}

\newpage

\appendix

\section{Detailed Instance Information}
\label{app:instances}
\todo{@Christian: Add table}

\newpage
\section{Detailed Experimental Results}
\label{app:detailed_results}
\todo{@Christian: Kriegen wir die Tabelle auf die gleiche Seite, wie die überschrift?}
\begin{table}
	\begin{center}
		\begin{tabular}{|l|c|c|c|c|}
			\multicolumn{5}{|l|}{Graphs}\\
			\hline
			PACE instances & Default & Articulation Points & st-cuts & Nested Dissection \\
			\hline
			36 & \textbf{10.21} & 10.41 & 10.45 & 12.74 \\
			37 & \textbf{58.13} & 59.33 & 59.27 & 60.26 \\
			38 & 67.47 & 61.72 & \textbf{18.12} & 72.77 \\
			39 & \textbf{537.83} & 547.08 & 544.39 & 551.70 \\
			40 & \textbf{25844.20} & 26601.00 & 26479.10 & 26900.90 \\
			41 & \textbf{270.02} & 284.60 & 279.70 & 278.19 \\
			42 & \textbf{205.42} & 217.20 & 215.51 & 212.22 \\
			43 & \textbf{969.00} & 1023.48 & 1018.21 & 999.58 \\
			44 & \textbf{521.65} & 550.51 & 547.69 & 537.32 \\
			45 & \textbf{141.87} & 149.31 & 148.19 & 146.17 \\
			46 & \textbf{608.31} & 619.57 & 618.73 & 626.23 \\
			47 & \textbf{328.48} & 335.14 & 334.53 & 338.44 \\
			48 & \textbf{141.28} & 144.33 & 143.85 & 146.00 \\
			49 & \textbf{99.57} & 101.74 & 101.54 & 103.05 \\
			50 & \textbf{273.57} & 279.44 & 278.75 & 282.33 \\
			51 & \textbf{317.19} & 333.67 & 331.68 & 326.00 \\
			52 & \textbf{124.50} & 131.05 & 130.15 & 128.29 \\
			53 & \textbf{337.10} & 354.42 & 352.59 & 346.27 \\
			54 & \textbf{181.47} & 190.87 & 190.06 & 186.62 \\
			55 & \textbf{38.43} & 40.39 & 40.22 & 39.96 \\
			56 & \textbf{539.92} & 550.90 & 549.20 & 556.05 \\
			57 & \textbf{375.37} & 383.05 & 382.23 & 386.42 \\
			58 & \textbf{268.92} & 274.49 & 273.88 & 277.08 \\
			59 & \textbf{74.87} & 76.46 & 76.29 & 77.47 \\
			60 & \textbf{447.50} & 456.42 & 455.53 & 460.46 \\
			61 & \textbf{123.48} & 129.59 & 129.22 & 127.10 \\
			62 & \textbf{370.89} & 389.56 & 387.77 & 380.82 \\
			63 & \textbf{384.56} & 404.36 & 402.24 & 394.98 \\
			64 & \textbf{166.84} & 175.37 & 174.48 & 171.65 \\
			65 & \textbf{203.81} & 214.19 & 212.83 & 209.66 \\
			66 & \textbf{45.56} & 46.53 & 46.41 & 47.42 \\
			67 & \textbf{679.61} & 693.04 & 690.51 & 698.86 \\
			68 & \textbf{48.57} & 49.59 & 49.34 & 50.45 \\
			69 & \textbf{242.23} & 247.10 & 246.81 & 249.45 \\
			70 & \textbf{65.52} & 66.90 & 66.82 & 67.84 \\
			71 & \textbf{199.87} & 210.09 & 208.38 & 205.73 \\
			72 & \textbf{258.45} & 271.57 & 269.79 & 265.81 \\
			73 & \textbf{241.51} & 254.08 & 252.92 & 248.50 \\
			74 & \textbf{39.60} & 41.67 & 41.53 & 41.14 \\
			75 & - & - & - & - \\
			\hline
			avg. runtime (all) & \textbf{1754.15} & 1781.32 & 1775.05 & 1787.43 \\
			geom. runtime (all) & 1.00 & 1.03 & \textbf{0.96} & 1.04 \\
			avg. runtime (finished) & \textbf{898.01} & 925.85 & 919.42 & 932.11 \\
			geom. runtime (finished) & 1.00 & 1.03 & \textbf{0.96} & 1.04 \\
			\hline			
		\end{tabular}
	\end{center}
	\caption{Decomposition based strategies - PACE}
\end{table}
\begin{table}
	\begin{center}
		\begin{tabular}{|l|c|c|c|c|}
			\hline	
			DIMACS instances & Default & Articulation Points & st-cuts & Nested Dissection \\
			\hline
			brock200\_1 & \textbf{763.08} & 784.09 & 766.22 & 788.60 \\
			brock200\_2 & \textbf{26.34} & 27.02 & 26.90 & 32.73 \\
			brock200\_3 & \textbf{129.34} & 132.98 & 130.21 & 138.46 \\
			brock200\_4 & \textbf{161.12} & 165.19 & 162.22 & 170.45 \\
			gen200\_p0 & \textbf{857.94} & 877.23 & 868.98 & 881.45 \\
			gen200\_p0 & \textbf{742.01} & 758.72 & 752.10 & 762.09 \\
			hamming6-4 & \textbf{0.13} & 0.14 & 0.15 & 0.49 \\
			hamming8-4 & \textbf{126.51} & 128.84 & 128.22 & 136.39 \\
			johnson16-2-4 & \textbf{227.76} & 236.37 & 230.36 & 236.15 \\
			johnson8-2-4 & \textbf{0.01} & 0.01 & 0.01 & 0.07 \\
			johnson8-4-4 & \textbf{0.36} & 0.38 & 0.37 & 1.11 \\
			p\_hat300-1 & \textbf{24.37} & 25.22 & 25.26 & 47.16 \\
			p\_hat300-2 & \textbf{32.97} & 33.77 & 33.62 & 49.72 \\
			p\_hat500-1 & \textbf{243.17} & 248.22 & 249.08 & 272.51 \\
			p\_hat500-2 & \textbf{579.09} & 588.73 & 585.12 & 608.76 \\
			\hline
			avg. runtime (all) & \textbf{260.95} & 267.13 & 263.92 & 275.08 \\
			geom. runtime (all) & \textbf{1.00} & 1.03 & 1.02 & 1.52 \\
			avg. runtime (finished) & \textbf{260.95} & 267.13 & 263.92 & 275.08 \\
			geom. runtime (finished) & \textbf{1.00} & 1.03 & 1.02 & 1.52 \\
			\hline
			\hline			
			SNAP instances & Default & Articulation Points & st-cuts & Nested Dissection \\
			\hline
			as-skitter & \textbf{11325.70} & 11683.30 & 11519.70 & 11751.30 \\
			deezer\_europe & - & - & - & - \\
			libimseti & \textbf{7875.81} & 8220.39 & 7996.73 & 8304.24 \\
			musae\_DE & - & - & - & - \\
			musae\_FR & \textbf{207.72} & 219.78 & 217.51 & 211.96 \\
			web-BerkStan & \textbf{753.08} & 1950.39 & 773.78 & 864.15 \\
			web-Google & 2.68 & 2.85 & \textbf{2.68} & 3.42 \\
			web-NotreDame & 117.01 & \textbf{91.67} & 118.49 & 162.66 \\
			web-Stanford & - & \textbf{47.63} & 162.74 & 176.02 \\
			\hline
			avg. runtime (all) & 14253.56 & 10468.45 & \textbf{10310.18} & 10385.97 \\
			geom. runtime (all) & 1.00 & \textbf{0.44} & 0.47 & 0.53 \\
			avg. runtime (finished) & \textbf{3380.33} & 3694.73 & 3438.15 & 3549.62 \\
			geom. runtime (finished) & \textbf{1.00} & 1.16 & 1.02 & 1.15 \\
			\hline
		\end{tabular}
	\end{center}
	\caption{Decomposition based strategies - DIMACS + SNAP}
\end{table}

\begin{table}
	\begin{center}
		\begin{tabular}{|l| c| c| c| c| r|}
			
			\multicolumn{6}{|l|}{Graphs}\\	
			\hline
			PACE instances & Default & Twin & Funnel & Unconfined & Combined \\
			\hline
			36 & 10.21 & 10.54 & - & 8.74 & 82.70 \\
			37 & \textbf{58.13} & 58.48 & 60.92 & 60.28 & 64.89 \\
			38 & 67.47 & 60.15 & \textbf{57.78} & 61.27 & 61.13 \\
			38 & 67.47 & 60.15 & \textbf{57.78} & 61.27 & 60.96 \\
			39 & 537.83 & 543.27 & \textbf{250.58} & 680.27 & 565.93 \\
			40 & 25844.20 & - & - & - & - \\
			41 & 270.02 & 268.97 & 254.10 & 273.52 & \textbf{252.91} \\
			42 & 205.42 & 207.38 & \textbf{205.10} & 210.39 & 213.93 \\
			43 & 969.00 & 969.00 & \textbf{938.21} & 997.21 & 951.74 \\
			44 & 521.65 & 514.22 & \textbf{481.62} & 527.71 & 506.06 \\
			45 & 141.87 & \textbf{141.73} & 143.46 & 146.70 & 158.07 \\
			46 & 608.31 & 608.30 & \textbf{545.61} & 612.11 & 548.83 \\
			47 & 328.48 & 323.82 & \textbf{310.85} & 330.40 & 321.96 \\
			48 & 141.28 & 140.85 & \textbf{132.06} & 144.19 & 139.99 \\
			49 & 99.57 & 99.96 & \textbf{97.25} & 105.16 & 103.45 \\
			50 & 273.57 & 272.54 & \textbf{267.95} & 281.00 & 284.53 \\
			51 & 317.19 & 313.95 & \textbf{294.33} & 321.63 & 314.84 \\
			52 & 124.50 & \textbf{124.09} & 124.82 & 129.66 & 130.62 \\
			53 & 337.10 & 333.76 & \textbf{314.75} & 341.61 & 334.37 \\
			54 & 181.47 & 180.34 & \textbf{171.84} & 186.41 & 180.53 \\
			55 & 38.43 & 38.34 & \textbf{38.15} & 39.99 & 40.74 \\
			56 & 539.92 & 534.14 & \textbf{518.57} & 546.90 & 532.02 \\
			57 & 375.37 & 367.72 & \textbf{336.68} & 372.51 & 347.94 \\
			58 & 268.92 & 264.53 & \textbf{262.87} & 272.00 & 285.23 \\
			59 & 74.87 & \textbf{74.80} & 75.50 & 76.68 & 78.07 \\
			60 & 447.50 & 440.75 & \textbf{423.89} & 451.06 & 442.38 \\
			61 & 123.48 & 123.04 & \textbf{119.75} & 128.04 & 125.53 \\
			62 & 370.89 & 367.02 & \textbf{351.17} & 378.97 & 364.31 \\
			63 & 384.56 & 381.94 & \textbf{357.91} & 393.52 & 372.65 \\
			64 & 166.84 & 164.41 & \textbf{157.72} & 168.88 & 166.24 \\
			65 & 203.81 & 203.81 & \textbf{196.75} & 210.29 & 200.99 \\
			66 & 45.56 & 45.55 & \textbf{44.70} & 47.20 & 46.39 \\
			67 & 679.61 & 668.85 & \textbf{641.34} & 681.78 & 683.53 \\
			68 & \textbf{48.57} & 48.85 & 50.44 & 50.56 & 54.42 \\
			69 & 242.23 & 239.70 & \textbf{229.38} & 247.51 & 239.35 \\
			70 & 65.52 & 66.23 & \textbf{60.17} & 69.43 & 62.96 \\
			71 & 199.87 & 199.69 & \textbf{184.09} & 200.48 & 199.84 \\
			72 & 258.45 & 254.42 & \textbf{248.32} & 260.58 & 249.93 \\
			73 & 241.51 & 238.87 & \textbf{234.67} & 244.29 & 258.96 \\
			74 & \textbf{39.60} & 39.70 & 40.42 & 41.61 & 42.23 \\
			75 & - & - & - & - & - \\
			\hline
			avg. runtime (all) & \textbf{1754.15} & 1999.85 & 2860.52 & 2008.82 & 2001.74 \\
			geom. runtime (all) & 1.00 & \textbf{1.00} & 1.17 & 1.03 & 1.07 \\
			avg. runtime (finished) & 264.89 & 262.72 & \textbf{244.25} & 272.45 & 262.85 \\
			geom. runtime (finished) & 1.00 & 0.99 & \textbf{0.94} & 1.02 & 1.00 \\
			\hline
		\end{tabular}
	\end{center}
	\caption{Reduction based strategies - PACE}
\end{table}
\begin{table}
	\begin{center}
		\begin{tabular}{|l| c| c| c| c| r|}
			\hline			
			DIMACS instances & Default & Twin & Funnel & Unconfined & Combined \\
			\hline
			brock200\_1 & \textbf{763.08} & 768.71 & 800.63 & 779.06 & 828.07 \\
			brock200\_2 & 26.34 & \textbf{25.57} & 26.89 & 25.76 & 27.84 \\
			brock200\_3 & \textbf{129.34} & 130.12 & 136.15 & 131.69 & 141.24 \\
			brock200\_4 & 161.12 & \textbf{160.17} & 168.70 & 161.64 & 174.85 \\
			gen200\_p0 & 857.94 & \textbf{765.15} & 921.30 & 892.94 & 980.81 \\
			gen200\_p0 & 742.01 & \textbf{717.09} & 722.51 & 722.20 & 723.54 \\
			hamming6-4 & \textbf{0.13} & 0.14 & 0.15 & 0.14 & 0.15 \\
			hamming8-4 & 126.51 & 110.36 & 115.22 & \textbf{110.18} & 118.44 \\
			johnson16-2-4 & \textbf{227.76} & 233.38 & 245.41 & 241.60 & 259.20 \\
			johnson8-2-4 & \textbf{0.01} & 0.01 & 0.01 & 0.01 & 0.01 \\
			johnson8-4-4 & \textbf{0.36} & 0.37 & 0.41 & 0.37 & 0.42 \\
			p\_hat300-1 & 24.37 & \textbf{22.31} & 23.44 & 22.34 & 24.19 \\
			p\_hat300-2 & 32.97 & \textbf{29.94} & 31.39 & 30.09 & 32.43 \\
			p\_hat500-1 & 243.17 & \textbf{227.73} & 236.05 & 229.19 & 243.66 \\
			p\_hat500-2 & 579.09 & \textbf{527.45} & 547.64 & 529.44 & 553.12 \\
			\hline
			avg. runtime (all) & 260.95 & \textbf{247.90} & 265.06 & 258.44 & 273.86 \\
			geom. runtime (all) & 1.00 & \textbf{0.96} & 1.02 & 0.98 & 1.05 \\
			avg. runtime (finished) & 260.95 & \textbf{247.90} & 265.06 & 258.44 & 273.86 \\
			geom. runtime (finished) & 1.00 & \textbf{0.96} & 1.02 & 0.98 & 1.05 \\
			\hline
			\hline
			SNAP instances & Default & Twin & Funnel & Unconfined & Combined \\
			as-skitter & 11325.70 & 11454.30 & \textbf{11230.80} & 11337.30 & 11405.00 \\
			deezer\_europe & - & - & - & - & - \\
			libimseti & \textbf{7875.81} & 7950.49 & 9270.56 & 7963.34 & 9568.96 \\
			musae\_DE & - & - & - & - & - \\
			musae\_FR & \textbf{207.72} & 215.38 & 235.90 & 247.38 & 268.96 \\
			web-BerkStan & \textbf{753.08} & 790.22 & 814.00 & 883.14 & 1046.89 \\
			web-Google & 2.68 & \textbf{2.12} & 2.13 & 2.23 & 2.24 \\
			web-NotreDame & 117.01 & \textbf{103.85} & 110.46 & 106.90 & 144.58 \\
			web-Stanford & - & - & - & - & - \\
			\hline
			avg. runtime (all) & \textbf{14253.56} & 14279.60 & 14407.09 & 14282.25 & 14492.96 \\
			geom. runtime (all) & 1.00 & \textbf{0.96} & 1.01 & 1.01 & 1.15 \\
			avg. runtime (finished) & \textbf{3380.33} & 3419.39 & 3610.64 & 3423.38 & 3739.44 \\
			geom. runtime (finished) & 1.00 & \textbf{0.96} & 1.01 & 1.01 & 1.15 \\
			\hline
		\end{tabular}
	\end{center}
	\caption{Reduction based strategies - DIMACS + SNAP}
\end{table}

\end{document}
